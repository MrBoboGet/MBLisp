(import json js)
(import lsp)
(import "Capabilities.lisp")
(eval-lsp (js:add-readers *READTABLE*))
(import debug)
(import text)




(defclass SourceBreakpoint ()
    (line 0)
    (column -1)
    (condition "")
    (hitCondition "")
    (logMessage "")
)
(defclass Breakpoint ()
    (id null)
    (verified false)
    (message null)
    (source null)
    (line null)
    (column null)
    (endLine null)
    (endColumn null)
)
(defclass source ()
    (name "")
    (path "")
)

(defclass SourceInfo ()
    (modified-time 0)
    (breakpoints (list))
    (file-index null)
)
(defclass Position ()
    (line -1)
    (col -1)
)
(defclass TrapState () 
    (trap-signals false)    
    (trap-depth-changed "")    
    (trap-new-func false)
)
(defclass StoredVar ()
    (evaluated false)
    (value null)
    (variable null)
)
(defclass Stopped-State () 
    (thread-stack-trace {})
    (stack-frames {})
    (variables {})
    (sub-var-ids {})
    (var-id 1)
)

(defclass StackFrame ()
    (id 0)
    (name "")
    (source null)
    (line 0)
    (column 0)
    (endLine null)
    (endColumn null)
)
(defclass Scope ()
    (name "")
    (variablesReference 0)
    (expensive false)
    (source null)
)
(defclass Variable ()
    (name "")
    (value "")
    (type null)
    (variablesReference 0)
)


(set loaded-sources (dict))
(set stopped-state (Stopped-State))
(set trap-state (TrapState))

(defun parse-path (path-string)
    (canonical (. path-string "path"))
)
(defun load-source (path)
    (set return-value (SourceInfo))
    (set (slot return-value file-index) (line-index (open path)))
    return-value
)
(defun get-source (path)
    (if (not (in path loaded-sources))
        (set (. loaded-sources path) (load-source path))
    )
    (. loaded-sources path)
)
(eval-lsp (add-readers *READTABLE*))


(defclass ProcessState ()
    (id 0)
)
(set process-state (ProcessState))

(defun resume-execution () 
    (set-trap-new-func (. trap-state 'trap-new-func))
    (set-trap-depth-changed (. trap-state 'trap-depth-changed))
    (set-trap-signals (. trap-state 'trap-signals))
    (resume (. process-state 'id))
)
(defun stopped ()
    (set-trap-new-func false)
    (set-trap-depth-changed "")
    (set-trap-signals false)
    (set stopped-state (Stopped-State))
    (set trap-state (TrapState))
    true
)
(defun finished ()
    (send-event "thread" {reason: "stopped", threadId: (. process-state 'id)  })
    (send-event "exited" {exitCode: 0})
    (stopped)
    true
)

(set first-stop true)

(defun trap-handler ()
    (set reason "breakpoint")
    (if (not first-stop) (set reason "step"))
    (set first-stop false)
    (send-event "stopped" {reason: reason,threadId: (. process-state 'id),allThreadsStopped: true})
    (stopped)
    (pause (. process-state 'id))
)


(defun parse-breakpoint (arg)
    (set return-value (SourceBreakpoint))
    (set (slot return-value line) (+ (. arg "line") line-offset))
    (if (in "column" arg)
        (set (slot return-value column) (+ (. arg "column") col-offset))
    )
    (if (in "condition" arg) (set (slot return-value condition) (. arg "condition")))
    (if (in "hitCondition"  arg) (set (slot return-value hitCondition) (. arg "hitCondition")))
    (if (in "logMessage"  arg) (set (slot return-value logMessage) (. arg "logMessage")))
    return-value
)
(defun parse-source (json-source)
    (set return-value (source))
    (if (in "name" json-source) (set (slot return-value name) (. json-source "name")))
    (if (in "path" json-source) (set (slot return-value path) (. json-source "path")))
    return-value
)
(defun handle-stepIn (arg)
 (set return-value (dict))
 (set thread-to-resume (. arg "threadId"))
 (set (. trap-state 'trap-depth-changed) "step")
 (resume-execution)
 return-value
)
(defun handle-stepOut (arg)
 (set return-value (dict))
 (set thread-to-resume (. arg "threadId"))
 (set (. trap-state 'trap-depth-changed) "step")
 (resume-execution)
 return-value
)
(defun handle-next (arg)
 (set return-value (make-dict))
 (set thread-to-resume (. arg "threadId"))
 (set (. trap-state 'trap-depth-changed) "next")
 (resume-execution)
 return-value
)
(defun handle-setBreakpoints (arg)
  (set source-path (parse-path (. arg "source")))
  (set breakpoints (map parse-breakpoint (. arg "breakpoints"))) 
  (if (in source-path loaded-sources) 
     (doit b (slot (. loaded-sources source-path) breakpoints)
         (remove-trap b)
     )
     (set (slot (. loaded-sources source-path) breakpoints) (list))
   else 
    (set (. loaded-sources source-path) (load-source source-path))
  )
  (set source-info (. loaded-sources source-path))
  (set return-breakpoints (list))
  (doit b breakpoints
    (set lisp-position (symbol 'asd (get-byte-position (slot source-info file-index) (. b 'line) (.  b 'column) ) (path-id source-path)))
    (set-trap lisp-position)
    (append (slot source-info breakpoints) lisp-position)
    (set return-breakpoint (Breakpoint))
    (set (slot return-breakpoint verified) true)
    (append return-breakpoints return-breakpoint)
  )
  {breakpoints: return-breakpoints}
)
(defun handle-setExceptionBreakpoints (arg)
  {breakpoints: []}
)
(defun handle-disconnect (arg)
  {}
)

(defun filter (l p)
    (set return-value (list))
    (doit e l
        (if  (p e) (append return-value e))
    )
    return-value
)


(defun handle-threads (arg)
 (set return-value (make-dict))
 (set threads (filter (active-threads) _(not (eq (int (this-thread)) _))))
 (set (index return-value "threads") (map _{id: _ , name: (str _ )}  threads))
 return-value
)

(defun create-stackframe (in-frame)
    (set return-value (StackFrame))
    (set (slot return-value id) (++ (slot stopped-state var-id) 1))
    (set (slot return-value name) (str (get-frame-name in-frame)))
    (set frame-location (get-frame-location in-frame))
    (set frame-uri  (uri frame-location))
    (if (not  (eq frame-uri "")) 
        (set (. return-value 'source) {name:"ligma",path: frame-uri} )
        (set file-index (.  (get-source frame-uri) 'file-index))
        (set (. return-value 'line) (+ (get-line file-index frame-location) 1))
        (set (. return-value 'column) (+ (get-col file-index frame-location) 1))
    )
    (set frame-id (slot return-value id))
    (set (. stopped-state 'stack-frames (slot return-value id)) return-value)
    (set new-var (StoredVar))
    (set (slot new-var value) (get-frame-envir in-frame))
    (set (. (slot stopped-state variables) frame-id) new-var)
    return-value
)
(defun handle-stackTrace (arg)
 (set return-value (dict))
 (set stack-frames (get-stack-frames (thread-handle (. arg "threadId"))))
 (pop stack-frames)
 (reverse stack-frames)
 (set (. return-value "stackFrames") (map create-stackframe  stack-frames))
 (set (. (slot stopped-state stack-frames) (. arg "threadId")) (. return-value "stackFrames"))
 return-value
)

(defgeneric get-vars)
(defgeneric get-var)
(defmethod get-var ((var any_t) )
    (set return-value (Variable))
    (set var-id (++ (. stopped-state 'var-id) 1))
    (if (applicable str var)
        (set (. return-value 'value) (str var))
     else
        (set  (. return-value  'value) "{}")
    )
    (set stored-var (StoredVar))
    (set (. stored-var 'value) var)
    (set (. stored-var 'variable) return-value)
    (set (. stopped-state 'variables var-id) stored-var)
    (set var-type (type var))
    (if (|| (eq var-type list_t) (eq var-type dict_t) (eq var-type object_t)) (set (. return-value 'variablesReference) var-id))
    return-value
)

(defmethod get-vars ((var list_t) id)
    (set return-value (list))
    (set child-ids (list))
    (doit i (range 0  (len var))
        (set current-id  (. stopped-state 'var-id))
        (set sub-var (get-var (. var i)))
        (set (. sub-var 'name) (str i))
        (append return-value sub-var)
        (append child-ids current-id)
    )
    return-value
)
(defmethod get-vars ((var dict_t) id)
    (set return-value (list))
    (set child-ids (list))
    (doit key (keys var)
        (set current-id  (. stopped-state 'var-id))
        (set sub-var (get-var (. var key)))
        (if (applicable str key)
            (set (. sub-var 'name) (str key))
         else 
            (set (. sub-var 'name) "{}")
        )
        (append return-value sub-var)
        (append child-ids current-id)
    )
    (set (. stopped-state 'sub-var-ids id) child-ids) 
    return-value
)
(defmethod get-vars ((var envir_t) id)
    (set return-value (list))
    (set child-ids (list))
    (doit key (vars var)
        (set current-id  (. stopped-state 'var-id))
        (set sub-var (get-var (. var key)))
        (set (. sub-var 'name) (str key))
        (append return-value sub-var)
        (append child-ids current-id)
    )
    (set (. stopped-state 'sub-var-ids id) child-ids) 
    return-value
)

(defmethod get-vars ((var any_t) id)
    (set return-value (list (get-var var)))
)

(defun handle-variables (arg)
 (set var-ref (. arg "variablesReference"))
 (set indexed-var (. stopped-state 'variables var-ref))
 (if (. indexed-var 'evaluated) 
        (return 
        {variables: (map _(cond (not (eq (type _) null_t))   (. stopped-state 'variables _ 'variable)  [])
            (. stopped-state 'sub-var-ids var-ref) ) })
 )
 (set (. indexed-var 'evaluated) true)
 (set new-vars (get-vars (slot indexed-var value)  var-ref))
 {variables: new-vars}
)


(defun convert-scope (lisp-scope frame-id)
    (set return-value (Scope))
    (set (slot return-value name) "slugma")
    (set (slot return-value variablesReference) frame-id)
    return-value
)
(defun handle-scopes (arg)
 (set frame-id (. arg "frameId"))
 {scopes: [(convert-scope (. stopped-state 'variables frame-id 'value) frame-id)]}
)
(set launch-path "")
(defun handle-launch (arg)
 (set launch-path (. arg "path"))
 {}
)
(defun handle-continue (arg)
    (resume-execution)
    {threadId: (int(. process-state 'id)),allThreadsContinued: true}
)

(defun handle-configurationDone (arg)
    (set new-envir (new-environment))
    (set (. process-state 'id) (thread _(progn (eval (load launch-path) new-envir) (finished))))
    (write debug-file "launching UwU")
    (write debug-file  "\n")
    (flush debug-file)
    {}
)

(set client-capabilities (make-dict))
(set line-offset 0)
(set col-offset 0)

(defun handle-initialize (arg)
 (set return-value capabilites)
 (set client-capabilities arg)
 (if (&& (in "linesStartAt1" arg) (. arg "linesStartAt1" ))
    (set line-offset -1)    
 )
 (if (&& (in "columnsStartAt1" arg) (. arg "columnsStartAt1" ))
    (set col-offset -1)    
 )
 return-value
)

(set request-handlers (make-dict 
                        ("stepIn" handle-stepIn)
                        ("stepOut" handle-stepIn)
                        ("next" handle-next)
                        ("initialize" handle-initialize)
                        ("setBreakpoints" handle-setBreakpoints)
                        ("setExceptionBreakpoints" handle-setExceptionBreakpoints)
                        ("disconnect" handle-disconnect)
                        ("threads" handle-threads)
                        ("stackTrace" handle-stackTrace)
                        ("variables" handle-variables )
                        ("scopes" handle-scopes )
                        ("launch" handle-launch)
                        ("continue" handle-continue )
                        ("configurationDone" handle-configurationDone  )
                      )
)
(set seq 1)
(defun get-seq ()
    (set return-value seq)
    (set seq (+ seq 1))
    return-value
)
(defun get-error (string)
    {id: 0,format: string,showUser: true}
)
(defun get-request-response (request)
  (set return-value (dict))
  (set command (. request "command"))
  (set (. return-value "request_seq") (. request "seq"))
  (set (. return-value "seq") (get-seq))
  (set (. return-value "command") command)
  (set (. return-value "type") "response")
  (if (not (in command request-handlers))
    (set (. return-value "success") false)
    (set (. return-value "body") (make-dict ("error" (get-error "request not implemented"))))
   else
    (try
    (
      (set (. return-value "body") ((. request-handlers command) (. request "arguments")))
      (set (. return-value "success") true)
    )
    catch (string_t e)
    (
      (set (. return-value "success") false)
      (set (. return-value "body") {error: (get-error e)})
    )
    catch (any_t e)
    (
      (set message "internal error")
      (if (applicable str e)
        (catch-all (set message (str e)))
      )
      (set (. return-value "success") false)
      (set (. return-value "body") {error: (get-error message)})
    )
    )
  )
  return-value
)
(defun  send-event (name body)
   (set message-to-send {seq: (get-seq), type: "event",event: name,body: body})
   (write debug-file (js:to-json-string message-to-send))
   (write debug-file "\n")
   (flush debug-file)
   (js:send-rpc *standard-output* message-to-send)
   (flush *standard-output*)
)

(set debug-file (open "DAPOutput.txt" "w"))



(defun stop-debugee ()
    (remove (. process-state 'id))
)
(defun main ()
    (set-trap-handler trap-handler)
    (set-exclude-thread (this-thread) true)
    (while true
        (set next-message (js:read-rpc *standard-input*))
        (write debug-file  (js:to-json-string next-message))
        (write debug-file  "\n")
        (flush debug-file)
        (if (eq (. next-message "type") "request")
          (set message-to-send (get-request-response next-message))
          (write debug-file  (js:to-json-string message-to-send))
          (write debug-file  "\n")
          (flush debug-file)
          (js:send-rpc *standard-output* message-to-send)
          (flush *standard-output*)
          (if (eq (. next-message "command") "initialize")
            (set message-to-send {seq: (get-seq), type: "event", event: "initialized"})
            (js:send-rpc *standard-output* message-to-send)
            (write debug-file (js:to-json-string message-to-send))
            (write debug-file  "\n")
            (flush debug-file)
           else if (eq (. next-message "command") "disconnect")
            (stop-debugee)
            (break)
          )
        )
    )
)
(main)
