(import json js)
(import lsp)
(import "Capabilities.lisp")
(eval-lsp (js:add-readers *READTABLE*))
(import debug)
(import text)




(defclass SourceBreakpoint ()
    (line 0)
    (column -1)
    (condition "")
    (hitCondition "")
    (logMessage "")
)
(defclass Breakpoint ()
    (id null)
    (verified false)
    (message null)
    (source null)
    (line null)
    (column null)
    (endLine null)
    (endColumn null)
)
(defclass source ()
    (name "")
    (path "")
)

(defclass SourceInfo ()
    (modified-time 0)
    (breakpoints (list))
    (file-index null)
)
(defclass Position ()
    (line -1)
    (col -1)
)
(defclass TrapState () 
    (trap-signals false)    
    (trap-depth "")    
    (trap-new-func false)
)
(defclass StoredVar ()
    (evaluated false)
    (value null)
    (variable null)
)
(defclass Stopped-State () 
    (thread-stack-trace {})
    (stack-frames {})
    (variables {})
    (sub-var-ids {})
    (var-id 1)
)

(defclass StackFrame ()
    (id 0)
    (name "")
    (source null)
    (line 0)
    (column 0)
    (endLine null)
    (endColumn null)
)
(defclass Scope ()
    (name "")
    (variablesReference 0)
    (expensive false)
    (source null)
)
(defclass Variable ()
    (name "")
    (value "")
    (type null)
    (variablesReference 0)
)


(set loaded-sources (dict))
(set stopped-state (Stopped-State))
(set trap-state (TrapState))

(defun parse-path (path-string)
    path-string
)
(defun load-source (path)
    (set return-value (SourceInfo))
    (set (slot return-value file-index) (line-index (open path)))
)
(eval-lsp (add-readers *READTABLE*))


(defclass ProcessState ()
    (id 0)
)
(set process-state (ProcessState))

(defun resume-execution () 
    (set-trap-new-func (. trap-state 'trap-new-func))
    (set-trap-depth-changed (. trap-state 'trap-depth-changed))
    (set-trap-signals (. trap-state 'trap-signals))
    (resume (. process-state 'id))
)
(defun stopped ()
    (set-trap-new-func false)
    (set-trap-depth-changed "")
    (set-trap-signals false)
    (set stopped-state (Stopped-State))
    true
)

(defun trap-handler ()
    (send-event "stopped" {reason: "breakpoint"})
    (stopped)
    (pause (. process-state 'id))
)


(defun parse-breakpoint (arg)
    (set return-value (SourceBreakpoint))
    (set (slot return-value line) (+ (. "line" arg) line-offset))
    (if (in "column" arg)
        (set (slot return-value column) (+ (. "column" arg) col-offset))
    )
    (if (in "condition" arg) (set (slot return-value condition) (. arg "condition")))
    (if (in "hitCondition"  arg) (set (slot return-value hitCondition) (. arg "hitCondition")))
    (if (in "logMessage"  arg) (set (slot return-value logMessage) (. arg "logMessage")))
    return-value
)
(defun parse-source (json-source)
    (set return-value (source))
    (if (in "name" json-source) (set (slot return-value name) (. json-source "name")))
    (if (in "path" json-source) (set (slot return-value path) (. json-source "path")))
    return-value
)
(defun handle-stepIn (arg)
 (set return-value (make-dict))
 (set (. trap-state 'trap-step) "step")
 (resume-execution)
 return-value
)
(defun handle-next (arg)
 (set return-value (make-dict))
 (set (. trap-state 'trap-step) "next")
 (resume-execution)
 return-value
)
(defun handle-setBreakpoints (arg)
  (set source-path (parse-path (. arg "source")))
  (set breakpoints (map parse-breakpoint (. arg "breakpoints"))) 
  (if (in source-path loaded-sources) 
     (doit b (slot (. loaded-sources source-path) breakpoints)
         (remove-trap b)
     )
     (set (slot (index loaded-sources source-path) breakpoints) (list))
   else 
    (set (index loaded-sources source-path) (load-source source-path))
  )
  (set source-info (. loaded-sources source-path))
  (set return-breakpoints (list))
  (doit b breakpoints
    (set lisp-position (symbol 'asd (get-byte-position (slot source-info file-index) b) (path-id source-path)))
    (set-trap lisp-position)
    (append (slot source-info breakpoints) lisp-position)
    (set return-breakpoint (Breakpoint))
    (set (slot return-breakpoint verified) true)
    (append return-breakpoints return-breakpoint)
  )
  {breakpoints: return-breakpoints}
)

(defun handle-threads (arg)
 (set return-value (make-dict))
 (set threads (active-threads))
 (set (index return-value "threads") (map _{id: _ , name: (str _ )}  threads  ))
 return-value
)

(defun create-stackframe (in-frame)
    (set return-value (StackFrame))
    (set (slot return-value id) (++ (slot stopped-state var-id) 1))
    (set (slot return-value name) "ligma")
    (set frame-id (slot return-value id))
    (set (. (slot stopped-state  stack-frames) (slot return-value id)) return-value)
    (set new-var (StoredVar))
    (set (slot new-var value) (get-frame-envir in-frame))
    (set (. (slot stopped-state variables) frame-id) new-var)
    return-value
)
(defun handle-stackTrace (arg)
 (set return-value (make-dict))
 (set stack-frames (get-stack-frames (. arg "threadId")))
 (set (. return-value "stackFrames") (map _(create-stackframe _) stack-frames))
 (set (. (slot stopped-state thread-frames) (. arg "threadId")) (. return-value "stackFrames"))
 return-value
)

(defgeneric get-vars)
(defgeneric get-var)
(defmethod get-var ((var any_t) )
    (set return-value (Variable))
    (set var-id (++ (. stopped-state 'var-id) 1))
    (set (. return-value 'value) (str var))
    (set stored-var (StoredVar))
    (set (. stored-var 'value) var)
    (set (. stored-var 'variable) return-value)
    (set (. stopped-state 'variables var-id) stored-var)
    (set var-type (type var))
    (if (|| (eq var-type list_t) (eq var-type dict_t) (eq var-type object_t)) (set (. return-value 'variablesReference) var-id))
    return-value
)
(defmethod get-vars ((var list_t) id)
    (set return-value (list))
    (set child-ids (list))
    (doit i (range 0  (len var))
        (set current-id  (stopped-state 'var-id))
        (set sub-var (get-var (. var i)))
        (set (. sub-var 'name) (str i))
        (append return-value sub-var)
        (append child-ids current-id)
    )
    return-value
)
(defmethod get-vars ((var dict_t) id)
    (set return-value (list))
    (set child-ids (list))
    (doit key (keys var)
        (set current-id  (stopped-state 'var-id))
        (set sub-var (get-var (. var key)))
        (set (. sub-var 'name) (str key))
        (append return-value sub-var)
        (append child-ids current-id)
    )
    (set (. stopped-state 'sub-var-ids id) child-ids) 
    return-value
)
(defmethod get-vars ((var any_t) id)
    (set return-value (list (get-var var)))
)

(defun handle-variables (arg)
 (set var-ref (. arg "variablesReference"))
 (set indexed-var (. stopped-state 'variables var-ref))
 (if (. indexed-var 'evaluated) (return (. stopped-state 
        {variables: (map _(. stopped-state 'variables _ 'variable)  (. stopped-state 'variables 'sub-var-ids var-ref) ) })))
 (set (. indexed-var 'evaluated) true)
 (set new-vars (get-vars (slot indexed-var value)))
 {variables: new-vars}
)


(defun convert-scope (lisp-scope)
    (set return-value (Scope))
    (set (slot return-value name) "slugma")
    return-value
)
(defun handle-scopes (arg)
 {scopes: (convert-scope (. (. stopped-state 'variables 'value) (. arg "framedId")))}
)
(defun handle-launch (arg)
 (set new-envir (new-environment))
 (set (. process-state 'id) (thread _(eval (load (. arg "path")) new-envir)))
 {}
)
(defun handle-continue (arg)
    (resume-execution)
    {}
)

(defun handle-configurationDone (arg)
 (set return-value (make-dict))
 return-value
)

(set client-capabilities (make-dict))
(set line-offset 0)
(set col-offset 0)

(defun handle-initialize (arg)
 (set return-value capabilites)
 (set client-capabilities arg)
 (if (&& (in "linesStartAt1" arg) (. arg "linesStartAt1" ))
    (set line-offset -1)    
 )
 (if (&& (in "columnsStartAt1" arg) (. arg "columnsStartAt1" ))
    (set col-offset -1)    
 )
 return-value
)

(set request-handlers (make-dict 
                        ("stepIn" handle-stepIn)
                        ("next" handle-next)
                        ("initialize" handle-initialize)
                        ("setBreakpoints" handle-setBreakpoints)
                        ("threads" handle-threads)
                        ("stackTrace" handle-stackTrace)
                        ("variables" handle-variables )
                        ("scopes" handle-scopes )
                        ("launch" handle-launch)
                        ("continue" handle-continue )
                        ("configurationDone" handle-configurationDone  )
                      )
)
(set seq 1)
(defun get-seq ()
    (set return-value seq)
    (set seq (+ seq 1))
    return-value
)
(defun get-error (string)
    {id: 0,format: string,showUser: true}
)
(defun get-request-response (request)
  (set return-value (dict))
  (set command (. request "command"))
  (set (. return-value "request_seq") (. request "seq"))
  (set (. return-value "seq") (get-seq))
  (set (. return-value "command") command)
  (set (. return-value "type") "response")
  (if (not (in command request-handlers))
    (set (. return-value "success") false)
    (set (. return-value "body") (make-dict ("error" (get-error "request not implemented"))))
   else
    (try
    (
      (set (. return-value "body") ((. request-handlers command) (. request "arguments")))
      (set (. return-value "success") true)
    )
    catch (string_t e)
    (
      (set (. return-value "success") false)
      (set (. return-value "body") {error: (get-error e)})
    )
    catch (any_t e)
    (
      (set (. return-value "success") false)
      (set (. return-value "body") {error: (get-error "internal error")})
    )
    )
  )
  return-value
)
(defun  send-event (name body)
   (js:send-rpc {seq: (get-seq), type: "event",event: name,body: body})
)

(set debug-file (open "DAPOutput.txt" "w"))

(defun main ()
    (set-trap-handler trap-handler)
    (while true
        (set next-message (js:read-rpc *standard-input*))
        (write debug-file  (js:to-json-string next-message))
        (write debug-file  "\n")
        (flush debug-file)
        (if (eq (. next-message "type") "request")
          (set message-to-send (get-request-response next-message))
          (write debug-file  (js:to-json-string message-to-send))
          (write debug-file  "\n")
          (flush debug-file)
          (js:send-rpc *standard-output* message-to-send)
          (flush *standard-output*)
          (if (eq (. next-message "command") "initialize")
            (set message-to-send {seq: (get-seq), type: "event", event: "initialized"})
            (js:send-rpc *standard-output* message-to-send)
            (write debug-file (js:to-json-string message-to-send))
            (write debug-file  "\n")
            (flush debug-file)
          )
        )
    )
)
(main)
